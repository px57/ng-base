{"ast":null,"code":"var _class;\nimport { webSocket } from 'rxjs/webSocket';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"src/modules/tools/services/libs.service\";\n;\nexport class WebsocketService {\n  // /**\n  //  * @description: \n  //  */\n  // private websocket_config: Array<WebSocketsConfig> = [\n  //   {\n  //     port: 4242,\n  //     pathname: 'ws/chatroom/?room=fr&fakeConnect=true',\n  //     service: ChatroomService,\n  //   },\n  //   {\n  //     port: 4242,\n  //     pathname: 'ws/playroom/?room=fr&fakeConnect=true',\n  //   }\n  // ];\n  /**\n   * @description:\n   */\n  constructor(router, l) {\n    this.router = router;\n    this.l = l;\n    /**\n     * @description:\n     */\n    this.subject = undefined;\n    /**\n     * @description:\n     */\n    this.consumerData = {};\n    /**\n     * @description:\n     */\n    this.websocket_config = [];\n    // this.completeWebsocketConfig();\n    // for (const ws_config of this.websocket_config) {\n    //   this.connection(ws_config);\n    // }\n  }\n  /**\n   * @description: Injection des elements essentielles a la configuration du websocket.\n   */\n  completeWebsocketConfig() {\n    // const config = [\n    //   {\n    //     service: this.chatroomService,\n    //   },\n    //   {\n    //     service: this.playroomService,\n    //   }\n    // ];\n    // for (let i = 0; i < config.length; i++) {\n    //   this.websocket_config[i].service = config[i].service;\n    //   this.websocket_config[i].wsService = this;\n    // } \n  }\n  /*\n   * @description: Ici ont souscrit au différents éléments à envoyer et recevoir.\n   */\n  connection(ws_config) {\n    const url = this.getWebsocketUrl(ws_config);\n    ws_config.wsStream = webSocket(url);\n    ws_config.wsStream.subscribe(msg => '',\n    // Called whenever there is a message from the server.\n    err => this.error_traitement(ws_config, err),\n    // Called if at any point WebSocket API signals some kind of error.\n    () => console.log('complete') // Called when connection is closed (for whatever reason).\n    );\n\n    this.receive(ws_config);\n    window.websocket = ws_config.wsStream;\n    // this.change_page();\n  }\n  /*\n   * @description: Il serait important par la suite de créer plusieurs possibilité de shéma.\n   */\n  receive(ws_config) {\n    ws_config.service.ws_connection = ws_config;\n    try {\n      ws_config.wsStream.asObservable().subscribe(msg => {\n        for (let key of Object.keys(msg)) {\n          const recept_key = `recept__${key}`;\n          let recept__function = ws_config.service[recept_key];\n          if (recept__function === undefined) {\n            alert(`recept__${key} is not defined`);\n            return;\n          }\n          ws_config.service[recept_key](msg[key]);\n        }\n      });\n    } catch (e) {}\n  }\n  /*\n   * @description: Recoit les erreurs du flux\n   * x. Tenter à la fin de reconnecter le flux.\n   */\n  error_traitement(ws_config, err) {\n    console.error('error_traitement'.repeat(1));\n    setTimeout(() => {\n      this.connection(ws_config);\n    }, 1000);\n  }\n  /**\n   * @description:\n   */\n  getWebsocketUrl(ws_config) {\n    return `${this.get_protocol()}${this.l.get_host()}:${ws_config.port}/${ws_config.pathname}`;\n  }\n  /**\n   * @description:\n   */\n  get_protocol() {\n    if (window.location.protocol === 'https:') {\n      return 'ws://';\n    }\n    return 'ws://';\n  }\n  /**\n   * @description:\n   */\n  send(ws_connection, params) {\n    if (ws_connection === undefined) {\n      return;\n    }\n    ws_connection.wsStream.next(params);\n  }\n  /**\n   * @description: Add the websocket config to the list of websocket config.\n   * and run the connection.\n  */\n  setConfig(ws_config) {\n    this.websocket_config.push(ws_config);\n    ws_config.wsService = this;\n    this.connection(ws_config);\n  }\n}\n_class = WebsocketService;\n_class.ɵfac = function WebsocketService_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.LibsService));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":"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","names":["webSocket","WebsocketService","constructor","router","l","undefined","completeWebsocketConfig","connection","ws_config","url","getWebsocketUrl","wsStream","subscribe","msg","err","error_traitement","console","log","receive","window","websocket","service","ws_connection","asObservable","key","Object","keys","recept_key","recept__function","alert","e","error","repeat","setTimeout","get_protocol","get_host","port","pathname","location","protocol","send","params","next","setConfig","websocket_config","push","wsService","factory","providedIn"],"sourceRoot":"","sources":["/var/projects/base/ng-base/src/modules/tools/services/websocket.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { webSocket } from 'rxjs/webSocket';\n// import { ChatroomService } from 'src/modules/chatroom/services/chatroom.service';\n// import { PlayroomService } from './playroom.service';\nimport { LibsService } from 'src/modules/tools/services/libs.service';\n\nimport { Router, NavigationEnd, NavigationStart } from '@angular/router';\n\nexport interface WebSocketsConfig {\n  pathname: string;\n  port: number;\n  service?: any;\n  wsService?: any;\n  wsStream?: any;\n};\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class WebsocketService {\n\n  /**\n   * @description: \n   */\n  public subject: any = undefined;\n\n  /**\n   * @description: \n   */\n  public consumerData: any = {};\n\n  /** \n   * @description:\n   */\n  private websocket_config: Array<WebSocketsConfig> = [ ];\n\n  // /**\n  //  * @description: \n  //  */\n  // private websocket_config: Array<WebSocketsConfig> = [\n  //   {\n  //     port: 4242,\n  //     pathname: 'ws/chatroom/?room=fr&fakeConnect=true',\n  //     service: ChatroomService,\n  //   },\n  //   {\n  //     port: 4242,\n  //     pathname: 'ws/playroom/?room=fr&fakeConnect=true',\n  //   }\n  // ];\n\n  /**\n   * @description: \n   */\n  constructor(\n    private router: Router,\n    private l: LibsService,\n    // public chatroomService: ChatroomService,\n    // public playroomService: PlayroomService,\n  ) {\n    // this.completeWebsocketConfig();\n    // for (const ws_config of this.websocket_config) {\n    //   this.connection(ws_config);\n    // }\n  }\n\n  /**\n   * @description: Injection des elements essentielles a la configuration du websocket.\n   */\n  private completeWebsocketConfig() {\n    // const config = [\n    //   {\n    //     service: this.chatroomService,\n    //   },\n    //   {\n    //     service: this.playroomService,\n    //   }\n    // ];\n    // for (let i = 0; i < config.length; i++) {\n    //   this.websocket_config[i].service = config[i].service;\n    //   this.websocket_config[i].wsService = this;\n    // } \n  }\n\n  /*\n   * @description: Ici ont souscrit au différents éléments à envoyer et recevoir.\n   */\n  public connection(ws_config: WebSocketsConfig): void {\n    const url = this.getWebsocketUrl(ws_config)\n    ws_config.wsStream = webSocket(url);\n    ws_config.wsStream.subscribe(\n      (msg: any) => '', // Called whenever there is a message from the server.\n      (err: any) => this.error_traitement(ws_config, err), // Called if at any point WebSocket API signals some kind of error.\n      () => console.log('complete') // Called when connection is closed (for whatever reason).\n    );\n    this.receive(ws_config);\n    (window as any).websocket = ws_config.wsStream;\n    // this.change_page();\n  }\n\n  /*\n   * @description: Il serait important par la suite de créer plusieurs possibilité de shéma.\n   */\n  public receive(ws_config: WebSocketsConfig): void {\n    ws_config.service.ws_connection = ws_config;\n\n    try {\n      ws_config.wsStream.asObservable().subscribe((msg: any) => {\n        for (let key of Object.keys(msg)) {\n          const recept_key = `recept__${key}`;\n          let recept__function: Function | undefined = ws_config.service[recept_key];\n          if (recept__function === undefined) {\n            alert (`recept__${key} is not defined`);\n            return; \n          }\n          ws_config.service[recept_key](msg[key]);\n        }\n      });\n    } catch (e) {}\n  }\n\n  /*\n   * @description: Recoit les erreurs du flux\n   * x. Tenter à la fin de reconnecter le flux.\n   */\n  public error_traitement(ws_config: WebSocketsConfig, err: any): void {\n    console.error('error_traitement'.repeat(1));\n    setTimeout(() => {\n      this.connection(ws_config);\n    }, 1000);\n  }\n\n  /**\n   * @description: \n   */\n  private getWebsocketUrl(ws_config: WebSocketsConfig): string {\n    return  `${this.get_protocol()}${this.l.get_host()}:${ws_config.port}/${ws_config.pathname}`;\n  }\n\n  /**\n   * @description: \n   */\n  private get_protocol(): string {\n    if (window.location.protocol === 'https:') {\n      return 'ws://';\n    }\n    return 'ws://';\n  }\n\n  /**\n   * @description: \n   */\n  public send(\n      ws_connection: WebSocketsConfig | undefined, \n      params: any): void {\n    if (ws_connection === undefined) {\n      return;\n    }\n    ws_connection.wsStream.next(params);\n  }\n\n  /**\n   * @description: Add the websocket config to the list of websocket config.\n   * and run the connection.\n  */\n  public setConfig(ws_config: WebSocketsConfig): void {\n    this.websocket_config.push(ws_config);\n    ws_config.wsService = this;\n    this.connection(ws_config);    \n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}