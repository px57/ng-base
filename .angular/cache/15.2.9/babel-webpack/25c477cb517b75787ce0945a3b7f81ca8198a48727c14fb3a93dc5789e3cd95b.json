{"ast":null,"code":"import { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./balance.service\";\nimport * as i2 from \"src/modules/profile/services/user.service\";\n;\n;\n;\n;\nexport let PlayroomService = /*#__PURE__*/(() => {\n  var _class;\n  class PlayroomService {\n    // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [LOGIC]\n    constructor(balanceService, userService) {\n      this.balanceService = balanceService;\n      this.userService = userService;\n      /**\n       * @description: The stream of data from the websocket\n       */\n      this.stream = new Subject();\n      /**\n       * @description:\n       */\n      this.stream_winning_number = new Subject();\n      /**\n       * @description: Envoyer une messages pour indiquer que c'est la fin de partie.\n       */\n      this.endpartystream = new Subject();\n      /**\n       * @description:\n       */\n      this.caps = new CapsuleTime();\n      // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [PARAMS]\n      /**\n       * @description:\n       * @param.time -> the time in the game in second\n       * @param.utc_timestamp the utc timestamp of the game server.\n       * @param.recept_time the time when the client receive the message.\n       */\n      this.init_party = {\n        time: 0,\n        utc_timestamp: 0\n      };\n      /**\n       * @description:\n       */\n      this.party = {\n        time: 0\n      };\n      /**\n       * @description:\n       */\n      this.timestrategy = [];\n      // TODO: Il faut creer un process de reset puissant pour chaque party\n      setTimeout(() => {\n        this.update_time();\n      }, 1000);\n    }\n    /**\n     * @description: update the time in the game.\n     */\n    update_time() {\n      // alert ('aoeoauoea')\n      if (this.init_party.recept_time === undefined) {\n        setTimeout(() => {\n          this.update_time();\n        }, 200);\n        return;\n      }\n      // -> La difference entre le temps actuel et le temps de reception de l'initialisation.\n      let diff_begin_now = new Date().getTime() / 1000 - this.init_party.recept_time.getTime() / 1000;\n      // -> La taille d'une partie en seconde.\n      let party_duration = this.get_party_duration();\n      // -> La difference entre le temps actuel et le temps de reception de l'initialisation.\n      let party = diff_begin_now % party_duration;\n      this.party.time = this.init_party.time + party;\n      this.party.time = this.party.time % party_duration;\n      this.caps = this.getTimeLaps(this.party.time);\n      this.stream.next({\n        event: 'party_time',\n        data: {\n          time: this.party.time,\n          caps: this.caps\n        }\n      });\n      // TODO: Il y aurait un bug a ce niveaux.\n      try {\n        setTimeout(() => {\n          this.update_time();\n        }, 200);\n      } catch (error) {}\n    }\n    /**\n     * @description: Get the duration maximum for the party, based in the timestrategy\n     */\n    get_party_duration() {\n      let max_duration_encountred = 0;\n      for (let i = 0; i < this.timestrategy.length; i++) {\n        const element = this.timestrategy[i];\n        if (element.time_end > max_duration_encountred) {\n          max_duration_encountred = element.time_end;\n        }\n      }\n      return max_duration_encountred;\n    }\n    /**\n     * @description:\n     * @param data\n     */\n    get_timelaps(timelas) {\n      return timelas.time_end - timelas.time_start;\n    }\n    /**\n     * @description:\n     */\n    getTimeLaps(time) {\n      let timelaps;\n      let timelaps_list = [];\n      console.log(time);\n      for (let i = 0; i < this.timestrategy.length; i++) {\n        const element = this.timestrategy[i];\n        if (time >= element.time_start && time <= element.time_end) {\n          timelaps_list.push(element.key);\n        }\n      }\n      console.log(timelaps_list);\n      let capsule = new CapsuleTime();\n      capsule.list_timelaps = timelaps_list;\n      return capsule;\n    }\n    // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [RECEPTOR]\n    /**\n     * @description:\n     */\n    recept__lottery_ticket_values(data) {\n      this.stream.next({\n        event: 'lottery_ticket_values',\n        data: data\n      });\n    }\n    /**\n     * @description:\n     */\n    recept__timestrategy(data) {\n      this.timestrategy = data;\n    }\n    /**\n     * @description:\n     */\n    recept__initparty(data) {\n      Object.assign(this.init_party, data);\n      this.init_party.recept_time = new Date();\n      this.get_party_duration();\n    }\n    /**\n     * @description:\n     */\n    recept__account_balance(data) {\n      this.balanceService.setBalance(data);\n      this.recept__ticket_list(data);\n      // this.stream.next({\n      //   event: 'account_balance',\n      //   data: data,\n      // });\n    }\n    /**\n     * @description:\n     */\n    recept__party_value(data) {}\n    /**\n     * @description:\n     */\n    recept__playing(data) {}\n    /**\n     * @description:\n     */\n    recept__ticket_list(data) {\n      if (typeof data === 'number') {\n        return;\n      }\n      this.stream.next({\n        event: 'ticket_list',\n        data: data\n      });\n    }\n    /**\n     * @description:\n     */\n    recept__error(data) {}\n    /**\n     * @description:\n     */\n    recept__winner_list(data) {}\n    /**\n     * @description:\n     */\n    recept__jackpot(data) {\n      this.stream.next({\n        event: 'jackpot',\n        data: data\n      });\n    }\n    /**\n     * @description:\n     */\n    recept__winning_number(data) {\n      this.printrun_winning_number = data;\n      this.printrun_run();\n    }\n    /**\n     * @description:\n     */\n    recept__new_party(data) {\n      window.location.reload();\n    }\n    /**\n     * @description:\n     */\n    send_selected_ticket(ticket) {\n      this.ws_connection?.wsService.send(this.ws_connection, {\n        play: ticket.value\n      });\n    }\n    /**\n     * @description:\n     */\n    printrun_run() {\n      setTimeout(() => {\n        if (this.printrun_winning_number === undefined) {\n          return;\n        }\n        ;\n        if (!this.caps.random_draw()) {\n          this.printrun_run();\n          return;\n        }\n        for (let bobine of this.printrun_winning_number) {\n          if (bobine.sended) {\n            continue;\n          }\n          if (bobine.whentotime <= this.party.time) {\n            bobine.sended = true;\n            this.stream_winning_number.next(bobine);\n          }\n        }\n        this.printrun_run();\n      }, 500);\n    }\n    /**\n     * @description:\n     */\n    endpartynext(event) {\n      if (!this.userService.is_authenticated()) {\n        if (this.caps.random_draw()) {\n          this.endpartynext('reset');\n        }\n        return;\n      }\n      this.endpartystream.next(event);\n    }\n  }\n  _class = PlayroomService;\n  _class.ɵfac = function PlayroomService_Factory(t) {\n    return new (t || _class)(i0.ɵɵinject(i1.BalanceService), i0.ɵɵinject(i2.UserService));\n  };\n  _class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac,\n    providedIn: 'root'\n  });\n  return PlayroomService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}