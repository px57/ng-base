{"ast":null,"code":"var _class;\nimport { webSocket } from 'rxjs/webSocket';\nimport { ChatroomService } from 'src/modules/chatroom/services/chatroom.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"src/modules/tools/services/libs.service\";\nimport * as i3 from \"src/modules/chatroom/services/chatroom.service\";\nimport * as i4 from \"./playroom.service\";\n;\nexport class WebsocketService {\n  /**\n   * @description:\n   */\n  constructor(router, l, chatroomService, playroomService) {\n    this.router = router;\n    this.l = l;\n    this.chatroomService = chatroomService;\n    this.playroomService = playroomService;\n    /**\n     * @description:\n     */\n    this.subject = undefined;\n    /**\n     * @description:\n     */\n    this.consumerData = {};\n    /**\n     * @description:\n     */\n    this.websocket_config = [{\n      port: 4242,\n      pathname: 'ws/chatroom/?room=fr&fakeConnect=true',\n      service: ChatroomService\n    }, {\n      port: 4242,\n      pathname: 'ws/playroom/?room=fr&fakeConnect=true'\n    }];\n    this.completeWebsocketConfig();\n    for (const ws_config of this.websocket_config) {\n      this.connection(ws_config);\n    }\n  }\n  /**\n   * @description: Injection des elements essentielles a la configuration du websocket.\n   */\n  completeWebsocketConfig() {\n    const config = [{\n      service: this.chatroomService\n    }, {\n      service: this.playroomService\n    }];\n    for (let i = 0; i < config.length; i++) {\n      this.websocket_config[i].service = config[i].service;\n      this.websocket_config[i].wsService = this;\n    }\n  }\n  /*\n   * @description: Ici ont souscrit au différents éléments à envoyer et recevoir.\n   */\n  connection(ws_config) {\n    const url = this.getWebsocketUrl(ws_config);\n    ws_config.wsStream = webSocket(url);\n    ws_config.wsStream.subscribe(msg => '',\n    // Called whenever there is a message from the server.\n    err => this.error_traitement(ws_config, err),\n    // Called if at any point WebSocket API signals some kind of error.\n    () => console.log('complete') // Called when connection is closed (for whatever reason).\n    );\n\n    this.receive(ws_config);\n    window.websocket = ws_config.wsStream;\n    // this.change_page();\n  }\n  /*\n   * @description: Il serait important par la suite de créer plusieurs possibilité de shéma.\n   */\n  receive(ws_config) {\n    ws_config.service.ws_connection = ws_config;\n    try {\n      ws_config.wsStream.asObservable().subscribe(msg => {\n        for (let key of Object.keys(msg)) {\n          const recept_key = `recept__${key}`;\n          let recept__function = ws_config.service[recept_key];\n          if (recept__function === undefined) {\n            alert(`recept__${key} is not defined`);\n            return;\n          }\n          ws_config.service[recept_key](msg[key]);\n        }\n      });\n    } catch (e) {}\n  }\n  /*\n   * @description: Recoit les erreurs du flux\n   * x. Tenter à la fin de reconnecter le flux.\n   */\n  error_traitement(ws_config, err) {\n    console.error('error_traitement'.repeat(1));\n    setTimeout(() => {\n      this.connection(ws_config);\n    }, 1000);\n  }\n  /**\n   * @description:\n   */\n  getWebsocketUrl(ws_config) {\n    return `${this.get_protocol()}${this.l.get_host()}:${ws_config.port}/${ws_config.pathname}`;\n  }\n  /**\n   * @description:\n   */\n  get_protocol() {\n    if (window.location.protocol === 'https:') {\n      return 'wss://';\n    }\n    return 'ws://';\n  }\n  /**\n   * @description:\n   */\n  send(ws_connection, params) {\n    if (ws_connection === undefined) {\n      return;\n    }\n    ws_connection.wsStream.next(params);\n  }\n}\n_class = WebsocketService;\n_class.ɵfac = function WebsocketService_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(i1.Router), i0.ɵɵinject(i2.LibsService), i0.ɵɵinject(i3.ChatroomService), i0.ɵɵinject(i4.PlayroomService));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":";AACA,SAASA,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,eAAe,QAAQ,gDAAgD;;;;;;AAc/E;AAKD,OAAM,MAAOC,gBAAgB;EA2B3B;;;EAGAC,YACUC,MAAc,EACdC,CAAc,EACfC,eAAgC,EAChCC,eAAgC;IAH/B,WAAM,GAANH,MAAM;IACN,MAAC,GAADC,CAAC;IACF,oBAAe,GAAfC,eAAe;IACf,oBAAe,GAAfC,eAAe;IAhCxB;;;IAGO,YAAO,GAAQC,SAAS;IAE/B;;;IAGO,iBAAY,GAAQ,EAAE;IAE7B;;;IAGQ,qBAAgB,GAA4B,CAClD;MACEC,IAAI,EAAE,IAAI;MACVC,QAAQ,EAAE,uCAAuC;MACjDC,OAAO,EAAEV;KACV,EACD;MACEQ,IAAI,EAAE,IAAI;MACVC,QAAQ,EAAE;KACX,CACF;IAWC,IAAI,CAACE,uBAAuB,EAAE;IAC9B,KAAK,MAAMC,SAAS,IAAI,IAAI,CAACC,gBAAgB,EAAE;MAC7C,IAAI,CAACC,UAAU,CAACF,SAAS,CAAC;;EAE9B;EAEA;;;EAGQD,uBAAuB;IAC7B,MAAMI,MAAM,GAAG,CACb;MACEL,OAAO,EAAE,IAAI,CAACL;KACf,EACD;MACEK,OAAO,EAAE,IAAI,CAACJ;KACf,CACF;IACD,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,MAAM,CAACE,MAAM,EAAED,CAAC,EAAE,EAAE;MACtC,IAAI,CAACH,gBAAgB,CAACG,CAAC,CAAC,CAACN,OAAO,GAAGK,MAAM,CAACC,CAAC,CAAC,CAACN,OAAO;MACpD,IAAI,CAACG,gBAAgB,CAACG,CAAC,CAAC,CAACE,SAAS,GAAG,IAAI;;EAE7C;EAEA;;;EAGOJ,UAAU,CAACF,SAA2B;IAC3C,MAAMO,GAAG,GAAG,IAAI,CAACC,eAAe,CAACR,SAAS,CAAC;IAC3CA,SAAS,CAACS,QAAQ,GAAGtB,SAAS,CAACoB,GAAG,CAAC;IACnCP,SAAS,CAACS,QAAQ,CAACC,SAAS,CACzBC,GAAQ,IAAK,EAAE;IAAE;IACjBC,GAAQ,IAAK,IAAI,CAACC,gBAAgB,CAACb,SAAS,EAAEY,GAAG,CAAC;IAAE;IACrD,MAAME,OAAO,CAACC,GAAG,CAAC,UAAU,CAAC,CAAC;IAAA,CAC/B;;IACD,IAAI,CAACC,OAAO,CAAChB,SAAS,CAAC;IACtBiB,MAAc,CAACC,SAAS,GAAGlB,SAAS,CAACS,QAAQ;IAC9C;EACF;EAEA;;;EAGOO,OAAO,CAAChB,SAA2B;IACxCA,SAAS,CAACF,OAAO,CAACqB,aAAa,GAAGnB,SAAS;IAE3C,IAAI;MACFA,SAAS,CAACS,QAAQ,CAACW,YAAY,EAAE,CAACV,SAAS,CAAEC,GAAQ,IAAI;QACvD,KAAK,IAAIU,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACZ,GAAG,CAAC,EAAE;UAChC,MAAMa,UAAU,GAAG,WAAWH,GAAG,EAAE;UACnC,IAAII,gBAAgB,GAAyBzB,SAAS,CAACF,OAAO,CAAC0B,UAAU,CAAC;UAC1E,IAAIC,gBAAgB,KAAK9B,SAAS,EAAE;YAClC+B,KAAK,CAAE,WAAWL,GAAG,iBAAiB,CAAC;YACvC;;UAEFrB,SAAS,CAACF,OAAO,CAAC0B,UAAU,CAAC,CAACb,GAAG,CAACU,GAAG,CAAC,CAAC;;MAE3C,CAAC,CAAC;KACH,CAAC,OAAOM,CAAC,EAAE;EACd;EAEA;;;;EAIOd,gBAAgB,CAACb,SAA2B,EAAEY,GAAQ;IAC3DE,OAAO,CAACc,KAAK,CAAC,kBAAkB,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;IAC3CC,UAAU,CAAC,MAAK;MACd,IAAI,CAAC5B,UAAU,CAACF,SAAS,CAAC;IAC5B,CAAC,EAAE,IAAI,CAAC;EACV;EAEA;;;EAGQQ,eAAe,CAACR,SAA2B;IACjD,OAAQ,GAAG,IAAI,CAAC+B,YAAY,EAAE,GAAG,IAAI,CAACvC,CAAC,CAACwC,QAAQ,EAAE,IAAIhC,SAAS,CAACJ,IAAI,IAAII,SAAS,CAACH,QAAQ,EAAE;EAC9F;EAEA;;;EAGQkC,YAAY;IAClB,IAAId,MAAM,CAACgB,QAAQ,CAACC,QAAQ,KAAK,QAAQ,EAAE;MACzC,OAAO,QAAQ;;IAEjB,OAAO,OAAO;EAChB;EAEA;;;EAGOC,IAAI,CACPhB,aAA2C,EAC3CiB,MAAW;IACb,IAAIjB,aAAa,KAAKxB,SAAS,EAAE;MAC/B;;IAEFwB,aAAa,CAACV,QAAQ,CAAC4B,IAAI,CAACD,MAAM,CAAC;EACrC;;SAvIW/C,gBAAgB;;mBAAhBA,MAAgB;AAAA;;SAAhBA,MAAgB;EAAAiD,SAAhBjD,MAAgB;EAAAkD,YAFf;AAAM","names":["webSocket","ChatroomService","WebsocketService","constructor","router","l","chatroomService","playroomService","undefined","port","pathname","service","completeWebsocketConfig","ws_config","websocket_config","connection","config","i","length","wsService","url","getWebsocketUrl","wsStream","subscribe","msg","err","error_traitement","console","log","receive","window","websocket","ws_connection","asObservable","key","Object","keys","recept_key","recept__function","alert","e","error","repeat","setTimeout","get_protocol","get_host","location","protocol","send","params","next","factory","providedIn"],"sourceRoot":"","sources":["/var/projects/gtender/client2/src/app/services/websocket.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { webSocket } from 'rxjs/webSocket';\nimport { ChatroomService } from 'src/modules/chatroom/services/chatroom.service';\nimport { PlayroomService } from './playroom.service';\nimport { LibsService } from 'src/modules/tools/services/libs.service';\n\nimport { Router, NavigationEnd, NavigationStart } from '@angular/router';\n\n// TODO: Trouver une maniere elegante pour lorsqu'il y a un plantage dans le websocket verrouiller le jeux, au passage.\n\nexport interface WebSocketsConfig {\n  pathname: string;\n  port: number;\n  service?: any;\n  wsService?: any;\n  wsStream?: any;\n};\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class WebsocketService {\n\n  /**\n   * @description: \n   */\n  public subject: any = undefined;\n\n  /**\n   * @description: \n   */\n  public consumerData: any = {};\n\n  /**\n   * @description: \n   */\n  private websocket_config: Array<WebSocketsConfig> = [\n    {\n      port: 4242,\n      pathname: 'ws/chatroom/?room=fr&fakeConnect=true',\n      service: ChatroomService,\n    },\n    {\n      port: 4242,\n      pathname: 'ws/playroom/?room=fr&fakeConnect=true',\n    }\n  ];\n\n  /**\n   * @description: \n   */\n  constructor(\n    private router: Router,\n    private l: LibsService,\n    public chatroomService: ChatroomService,\n    public playroomService: PlayroomService,\n  ) {\n    this.completeWebsocketConfig();\n    for (const ws_config of this.websocket_config) {\n      this.connection(ws_config);\n    }\n  }\n\n  /**\n   * @description: Injection des elements essentielles a la configuration du websocket.\n   */\n  private completeWebsocketConfig() {\n    const config = [\n      {\n        service: this.chatroomService,\n      },\n      {\n        service: this.playroomService,\n      }\n    ];\n    for (let i = 0; i < config.length; i++) {\n      this.websocket_config[i].service = config[i].service;\n      this.websocket_config[i].wsService = this;\n    } \n  }\n\n  /*\n   * @description: Ici ont souscrit au différents éléments à envoyer et recevoir.\n   */\n  public connection(ws_config: WebSocketsConfig): void {\n    const url = this.getWebsocketUrl(ws_config)\n    ws_config.wsStream = webSocket(url);\n    ws_config.wsStream.subscribe(\n      (msg: any) => '', // Called whenever there is a message from the server.\n      (err: any) => this.error_traitement(ws_config, err), // Called if at any point WebSocket API signals some kind of error.\n      () => console.log('complete') // Called when connection is closed (for whatever reason).\n    );\n    this.receive(ws_config);\n    (window as any).websocket = ws_config.wsStream;\n    // this.change_page();\n  }\n\n  /*\n   * @description: Il serait important par la suite de créer plusieurs possibilité de shéma.\n   */\n  public receive(ws_config: WebSocketsConfig): void {\n    ws_config.service.ws_connection = ws_config;\n\n    try {\n      ws_config.wsStream.asObservable().subscribe((msg: any) => {\n        for (let key of Object.keys(msg)) {\n          const recept_key = `recept__${key}`;\n          let recept__function: Function | undefined = ws_config.service[recept_key];\n          if (recept__function === undefined) {\n            alert (`recept__${key} is not defined`);\n            return; \n          }\n          ws_config.service[recept_key](msg[key]);\n        }\n      });\n    } catch (e) {}\n  }\n\n  /*\n   * @description: Recoit les erreurs du flux\n   * x. Tenter à la fin de reconnecter le flux.\n   */\n  public error_traitement(ws_config: WebSocketsConfig, err: any): void {\n    console.error('error_traitement'.repeat(1));\n    setTimeout(() => {\n      this.connection(ws_config);\n    }, 1000);\n  }\n\n  /**\n   * @description: \n   */\n  private getWebsocketUrl(ws_config: WebSocketsConfig): string {\n    return  `${this.get_protocol()}${this.l.get_host()}:${ws_config.port}/${ws_config.pathname}`;\n  }\n\n  /**\n   * @description: \n   */\n  private get_protocol(): string {\n    if (window.location.protocol === 'https:') {\n      return 'wss://';\n    }\n    return 'ws://';\n  }\n\n  /**\n   * @description: \n   */\n  public send(\n      ws_connection: WebSocketsConfig | undefined, \n      params: any): void {\n    if (ws_connection === undefined) {\n      return;\n    }\n    ws_connection.wsStream.next(params);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}