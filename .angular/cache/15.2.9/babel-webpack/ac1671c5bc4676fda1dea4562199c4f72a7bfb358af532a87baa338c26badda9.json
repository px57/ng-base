{"ast":null,"code":"var _class;\nimport { Subject } from 'rxjs';\nimport { CapsuleTime } from 'src/app/classes/capsule-time.class';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./balance.service\";\nimport * as i2 from \"src/modules/profile/services/user.service\";\nexport { CapsuleTime };\n;\n;\n;\n;\nexport class PlayroomService {\n  // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [LOGIC]\n  constructor(balanceService, userService) {\n    this.balanceService = balanceService;\n    this.userService = userService;\n    /**\n     * @description: The stream of data from the websocket\n     */\n    this.stream = new Subject();\n    /**\n     * @description:\n     */\n    this.stream_winning_number = new Subject();\n    /**\n     * @description: Envoyer une messages pour indiquer que c'est la fin de partie.\n     */\n    this.endpartystream = new Subject();\n    /**\n     * @description:\n     */\n    this.caps = new CapsuleTime();\n    // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [PARAMS]\n    /**\n     * @description:\n     * @param.time -> the time in the game in second\n     * @param.utc_timestamp the utc timestamp of the game server.\n     * @param.recept_time the time when the client receive the message.\n     */\n    this.init_party = {\n      time: 0,\n      utc_timestamp: 0\n    };\n    /**\n     * @description:\n     */\n    this.party = {\n      time: 0\n    };\n    /**\n     * @description:\n     */\n    this.timestrategy = [];\n    // TODO: Il faut creer un process de reset puissant pour chaque party\n    setTimeout(() => {\n      this.update_time();\n    }, 1000);\n  }\n  /**\n   * @description: update the time in the game.\n   */\n  update_time() {\n    // alert ('aoeoauoea')\n    if (this.init_party.recept_time === undefined) {\n      setTimeout(() => {\n        this.update_time();\n      }, 200);\n      return;\n    }\n    // -> La difference entre le temps actuel et le temps de reception de l'initialisation.\n    let diff_begin_now = new Date().getTime() / 1000 - this.init_party.recept_time.getTime() / 1000;\n    // -> La taille d'une partie en seconde.\n    let party_duration = this.get_party_duration();\n    // -> La difference entre le temps actuel et le temps de reception de l'initialisation.\n    let party = diff_begin_now % party_duration;\n    this.party.time = this.init_party.time + party;\n    this.party.time = this.party.time % party_duration;\n    this.caps = this.getTimeLaps(this.party.time);\n    this.stream.next({\n      event: 'party_time',\n      data: {\n        time: this.party.time,\n        caps: this.caps\n      }\n    });\n    // TODO: Il y aurait un bug a ce niveaux.\n    try {\n      setTimeout(() => {\n        this.update_time();\n      }, 200);\n    } catch (error) {}\n  }\n  /**\n   * @description: Get the duration maximum for the party, based in the timestrategy\n   */\n  get_party_duration() {\n    let max_duration_encountred = 0;\n    for (let i = 0; i < this.timestrategy.length; i++) {\n      const element = this.timestrategy[i];\n      if (element.time_end > max_duration_encountred) {\n        max_duration_encountred = element.time_end;\n      }\n    }\n    return max_duration_encountred;\n  }\n  /**\n   * @description:\n   * @param data\n   */\n  get_timelaps(timelas) {\n    return timelas.time_end - timelas.time_start;\n  }\n  /**\n   * @description:\n   */\n  getTimeLaps(time) {\n    let timelaps;\n    let timelaps_list = [];\n    console.log(time);\n    for (let i = 0; i < this.timestrategy.length; i++) {\n      const element = this.timestrategy[i];\n      if (time >= element.time_start && time <= element.time_end) {\n        timelaps_list.push(element.key);\n      }\n    }\n    let capsule = new CapsuleTime();\n    capsule.list_timelaps = timelaps_list;\n    return capsule;\n  }\n  // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [RECEPTOR]\n  /**\n   * @description:\n   */\n  recept__lottery_ticket_values(data) {\n    this.stream.next({\n      event: 'lottery_ticket_values',\n      data: data\n    });\n  }\n  /**\n   * @description:\n   */\n  recept__timestrategy(data) {\n    this.timestrategy = data;\n  }\n  /**\n   * @description:\n   */\n  recept__initparty(data) {\n    Object.assign(this.init_party, data);\n    this.init_party.recept_time = new Date();\n    this.get_party_duration();\n  }\n  /**\n   * @description:\n   */\n  recept__account_balance(data) {\n    this.balanceService.setBalance(data);\n    this.recept__ticket_list(data);\n    // this.stream.next({\n    //   event: 'account_balance',\n    //   data: data,\n    // });\n  }\n  /**\n   * @description:\n   */\n  recept__party_value(data) {}\n  /**\n   * @description:\n   */\n  recept__playing(data) {}\n  /**\n   * @description:\n   */\n  recept__ticket_list(data) {\n    if (typeof data === 'number') {\n      return;\n    }\n    this.stream.next({\n      event: 'ticket_list',\n      data: data\n    });\n  }\n  /**\n   * @description:\n   */\n  recept__error(data) {}\n  /**\n   * @description:\n   */\n  recept__winner_list(data) {}\n  /**\n   * @description:\n   */\n  recept__jackpot(data) {\n    this.stream.next({\n      event: 'jackpot',\n      data: data\n    });\n  }\n  /**\n   * @description:\n   */\n  recept__winning_number(data) {\n    this.printrun_winning_number = data;\n    this.printrun_run();\n  }\n  /**\n   * @description:\n   */\n  recept__new_party(data) {\n    window.location.reload();\n  }\n  /**\n   * @description:\n   */\n  send_selected_ticket(ticket) {\n    this.ws_connection?.wsService.send(this.ws_connection, {\n      play: ticket.value\n    });\n  }\n  /**\n   * @description:\n   */\n  printrun_run() {\n    setTimeout(() => {\n      if (this.printrun_winning_number === undefined) {\n        return;\n      }\n      ;\n      if (!this.caps.random_draw()) {\n        this.printrun_run();\n        return;\n      }\n      for (let bobine of this.printrun_winning_number) {\n        if (bobine.sended) {\n          continue;\n        }\n        if (bobine.whentotime <= this.party.time) {\n          bobine.sended = true;\n          this.stream_winning_number.next(bobine);\n        }\n      }\n      this.printrun_run();\n    }, 500);\n  }\n  /**\n   * @description:\n   */\n  endpartynext(event) {\n    if (!this.userService.is_authenticated()) {\n      if (this.caps.random_draw()) {\n        this.endpartynext('reset');\n      }\n      return;\n    }\n    this.endpartystream.next(event);\n  }\n}\n_class = PlayroomService;\n_class.ɵfac = function PlayroomService_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(i1.BalanceService), i0.ɵɵinject(i2.UserService));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":";AACA,SAASA,OAAO,QAAQ,MAAM;AAI9B,SAASC,WAAW,QAAQ,oCAAoC;;;;AAEhE,SAASA,WAAW;AA2BnB;AASA;AAUA;AAQA;AAKD,OAAM,MAAOC,eAAe;EAuD1B;EAEAC,YACUC,cAA8B,EAC9BC,WAAwB;IADxB,mBAAc,GAAdD,cAAc;IACd,gBAAW,GAAXC,WAAW;IArDrB;;;IAGO,WAAM,GAA4B,IAAIL,OAAO,EAAkB;IAEtE;;;IAGO,0BAAqB,GAAiB,IAAIA,OAAO,EAAO;IAO/D;;;IAGO,mBAAc,GAAiB,IAAIA,OAAO,EAAO;IAExD;;;IAGO,SAAI,GAAgB,IAAIC,WAAW,EAAE;IAE5C;IACA;;;;;;IAMO,eAAU,GAAc;MAC7BK,IAAI,EAAE,CAAC;MACPC,aAAa,EAAE;KAChB;IAED;;;IAGO,UAAK,GAAG;MACbD,IAAI,EAAE;KACP;IAED;;;IAGO,iBAAY,GAAwB,EAAE;IAQ3C;IACAE,UAAU,CAAC,MAAK;MACd,IAAI,CAACC,WAAW,EAAE;IACpB,CAAC,EAAE,IAAI,CAAC;EACV;EAEA;;;EAGOA,WAAW;IAChB;IACA,IAAI,IAAI,CAACC,UAAU,CAACC,WAAW,KAAKC,SAAS,EAAE;MAC7CJ,UAAU,CAAC,MAAK;QACd,IAAI,CAACC,WAAW,EAAE;MACpB,CAAC,EAAE,GAAG,CAAC;MACP;;IAGF;IACA,IAAII,cAAc,GAAY,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE,GAAG,IAAI,GAAI,IAAI,CAACL,UAAU,CAACC,WAAW,CAACI,OAAO,EAAE,GAAG,IAAI;IAEzG;IACA,IAAIC,cAAc,GAAW,IAAI,CAACC,kBAAkB,EAAE;IAEtD;IACA,IAAIC,KAAK,GAAGL,cAAc,GAAGG,cAAc;IAE3C,IAAI,CAACE,KAAK,CAACZ,IAAI,GAAG,IAAI,CAACI,UAAU,CAACJ,IAAI,GAAGY,KAAK;IAC9C,IAAI,CAACA,KAAK,CAACZ,IAAI,GAAG,IAAI,CAACY,KAAK,CAACZ,IAAI,GAAGU,cAAc;IAElD,IAAI,CAACG,IAAI,GAAG,IAAI,CAACC,WAAW,CAAC,IAAI,CAACF,KAAK,CAACZ,IAAI,CAAC;IAC7C,IAAI,CAACe,MAAM,CAACC,IAAI,CAAC;MACfC,KAAK,EAAE,YAAY;MACnBC,IAAI,EAAE;QACJlB,IAAI,EAAE,IAAI,CAACY,KAAK,CAACZ,IAAI;QACrBa,IAAI,EAAE,IAAI,CAACA;;KAEd,CAAC;IAEF;IACA,IAAI;MACFX,UAAU,CAAC,MAAK;QACd,IAAI,CAACC,WAAW,EAAE;MACpB,CAAC,EAAE,GAAG,CAAC;KACR,CAAC,OAAOgB,KAAK,EAAE;EAClB;EAEA;;;EAGOR,kBAAkB;IACvB,IAAIS,uBAAuB,GAAG,CAAC;IAC/B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACC,YAAY,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;MACjD,MAAMG,OAAO,GAAG,IAAI,CAACF,YAAY,CAACD,CAAC,CAAC;MACpC,IAAIG,OAAO,CAACC,QAAQ,GAAGL,uBAAuB,EAAE;QAC9CA,uBAAuB,GAAGI,OAAO,CAACC,QAAQ;;;IAG9C,OAAOL,uBAAuB;EAChC;EAEA;;;;EAIOM,YAAY,CAACC,OAA6B;IAC/C,OAAOA,OAAO,CAACF,QAAQ,GAAGE,OAAO,CAACC,UAAU;EAC9C;EAEA;;;EAGOd,WAAW,CAACd,IAAY;IAC7B,IAAI6B,QAA0C;IAC9C,IAAIC,aAAa,GAAkB,EAAE;IACrCC,OAAO,CAACC,GAAG,CAAChC,IAAI,CAAC;IACjB,KAAK,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACC,YAAY,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;MACjD,MAAMG,OAAO,GAAG,IAAI,CAACF,YAAY,CAACD,CAAC,CAAC;MACpC,IAAIrB,IAAI,IAAIwB,OAAO,CAACI,UAAU,IAAI5B,IAAI,IAAIwB,OAAO,CAACC,QAAQ,EAAE;QAC1DK,aAAa,CAACG,IAAI,CAACT,OAAO,CAACU,GAAG,CAAC;;;IAInC,IAAIC,OAAO,GAAG,IAAIxC,WAAW,EAAE;IAC/BwC,OAAO,CAACC,aAAa,GAAGN,aAAa;IACrC,OAAOK,OAAO;EAChB;EAEA;EACA;;;EAGOE,6BAA6B,CAACnB,IAAS;IAC5C,IAAI,CAACH,MAAM,CAACC,IAAI,CAAC;MACfC,KAAK,EAAE,uBAAuB;MAC9BC,IAAI,EAAEA;KACP,CAAC;EACJ;EAEA;;;EAGOoB,oBAAoB,CAACpB,IAAyB;IACnD,IAAI,CAACI,YAAY,GAAGJ,IAAI;EAC1B;EAEA;;;EAGOqB,iBAAiB,CAACrB,IAAS;IAChCsB,MAAM,CAACC,MAAM,CAAC,IAAI,CAACrC,UAAU,EAAEc,IAAI,CAAC;IACpC,IAAI,CAACd,UAAU,CAACC,WAAW,GAAG,IAAIG,IAAI,EAAE;IACxC,IAAI,CAACG,kBAAkB,EAAE;EAC3B;EAEA;;;EAGO+B,uBAAuB,CAACxB,IAAS;IACtC,IAAI,CAACpB,cAAc,CAAC6C,UAAU,CAACzB,IAAI,CAAC;IACpC,IAAI,CAAC0B,mBAAmB,CAAC1B,IAAI,CAAC;IAC9B;IACA;IACA;IACA;EACF;EAEA;;;EAGO2B,mBAAmB,CAAC3B,IAAS,GAAI;EAExC;;;EAGO4B,eAAe,CAAC5B,IAAS,GAAI;EAEpC;;;EAGO0B,mBAAmB,CAAC1B,IAAS;IAClC,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC5B;;IAGF,IAAI,CAACH,MAAM,CAACC,IAAI,CAAC;MACfC,KAAK,EAAE,aAAa;MACpBC,IAAI,EAAEA;KACP,CAAC;EACJ;EAEA;;;EAGO6B,aAAa,CAAC7B,IAAS,GAAI;EAElC;;;EAGO8B,mBAAmB,CAAC9B,IAAS,GAEpC;EAEA;;;EAGO+B,eAAe,CAAC/B,IAAS;IAC9B,IAAI,CAACH,MAAM,CAACC,IAAI,CAAC;MACfC,KAAK,EAAE,SAAS;MAChBC,IAAI,EAAEA;KACP,CAAC;EACJ;EAEA;;;EAGOgC,sBAAsB,CAAChC,IAAS;IACrC,IAAI,CAACiC,uBAAuB,GAAGjC,IAAI;IACnC,IAAI,CAACkC,YAAY,EAAE;EACrB;EAEA;;;EAGOC,iBAAiB,CAACnC,IAAS;IAChCoC,MAAM,CAACC,QAAQ,CAACC,MAAM,EAAE;EAC1B;EAEA;;;EAGOC,oBAAoB,CAACC,MAAW;IACrC,IAAI,CAACC,aAAa,EAAEC,SAAS,CAACC,IAAI,CAChC,IAAI,CAACF,aAAa,EAClB;MACEG,IAAI,EAAEJ,MAAM,CAACK;KAChB,CAAC;EACJ;EAEA;;;EAGOX,YAAY;IACjBlD,UAAU,CAAC,MAAK;MACd,IAAI,IAAI,CAACiD,uBAAuB,KAAK7C,SAAS,EAAE;QAC9C;;MACD;MAED,IAAI,CAAC,IAAI,CAACO,IAAI,CAACmD,WAAW,EAAE,EAAE;QAC5B,IAAI,CAACZ,YAAY,EAAE;QACnB;;MAGF,KAAK,IAAIa,MAAM,IAAI,IAAI,CAACd,uBAAuB,EAAE;QAC/C,IAAIc,MAAM,CAACC,MAAM,EAAE;UAAE;;QAErB,IAAID,MAAM,CAACE,UAAU,IAAI,IAAI,CAACvD,KAAK,CAACZ,IAAI,EAAE;UACxCiE,MAAM,CAACC,MAAM,GAAG,IAAI;UACpB,IAAI,CAACE,qBAAqB,CAACpD,IAAI,CAACiD,MAAM,CAAC;;;MAG3C,IAAI,CAACb,YAAY,EAAE;IACrB,CAAC,EAAE,GAAG,CAAC;EACT;EAEA;;;EAGOiB,YAAY,CAACpD,KAAmC;IACrD,IAAI,CAAC,IAAI,CAAClB,WAAW,CAACuE,gBAAgB,EAAE,EAAE;MACxC,IAAI,IAAI,CAACzD,IAAI,CAACmD,WAAW,EAAE,EAAE;QAC3B,IAAI,CAACK,YAAY,CAAC,OAAO,CAAC;;MAE5B;;IAEF,IAAI,CAACE,cAAc,CAACvD,IAAI,CAACC,KAAK,CAAC;EACjC;;SAzSWrB,eAAe;;mBAAfA,MAAe;AAAA;;SAAfA,MAAe;EAAA4E,SAAf5E,MAAe;EAAA6E,YAFd;AAAM","names":["Subject","CapsuleTime","PlayroomService","constructor","balanceService","userService","time","utc_timestamp","setTimeout","update_time","init_party","recept_time","undefined","diff_begin_now","Date","getTime","party_duration","get_party_duration","party","caps","getTimeLaps","stream","next","event","data","error","max_duration_encountred","i","timestrategy","length","element","time_end","get_timelaps","timelas","time_start","timelaps","timelaps_list","console","log","push","key","capsule","list_timelaps","recept__lottery_ticket_values","recept__timestrategy","recept__initparty","Object","assign","recept__account_balance","setBalance","recept__ticket_list","recept__party_value","recept__playing","recept__error","recept__winner_list","recept__jackpot","recept__winning_number","printrun_winning_number","printrun_run","recept__new_party","window","location","reload","send_selected_ticket","ticket","ws_connection","wsService","send","play","value","random_draw","bobine","sended","whentotime","stream_winning_number","endpartynext","is_authenticated","endpartystream","factory","providedIn"],"sourceRoot":"","sources":["/var/projects/gtender/client2/src/app/services/playroom.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { WebSocketsConfig } from './websocket.service';\nimport { BalanceService } from './balance.service';\nimport { UserService } from 'src/modules/profile/services/user.service';\nimport { CapsuleTime } from 'src/app/classes/capsule-time.class';\n\nexport { CapsuleTime };\n\n\n/**\n * @description:\n{\n                        bobine: 3,     // -> the bobine of the ticket\n                        number: 1,     // -> the number of the ticket\n                        whentotime: 7, // -> the time to show in the party\n                    } \n */\nexport interface PrintRunWinningNumber {\n  bobine: number,\n  number: number,\n  whentotime: number,\n  sended?: boolean,\n}\n\n\n/**\n * @description: \n */\ninterface TimeStrategyTimeLaps {\n  key: string, \n  name: string, \n  time_start: number,\n  time_end: number,\n};\n\n/**\n * @description: \n */\ninterface TimeParty {\n  time: number,\n  utc_timestamp: number,\n  recept_time?: Date,\n};\n\n/**\n * @description: \n */\ninterface TimeStrategy {\n  key: string,\n  name: string,\n  time_end: number,\n  time_start: number,\n};\n\n/**\n * @description: \n */\nexport interface PlayroomStream {\n  event: string,\n  data: any,\n};\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PlayroomService {\n  /**\n   * @description: \n   */\n  public ws_connection: WebSocketsConfig | undefined;\n\n  /**\n   * @description: The stream of data from the websocket \n   */\n  public stream: Subject<PlayroomStream> = new Subject<PlayroomStream>();\n\n  /**\n   * @description: \n   */\n  public stream_winning_number: Subject<any> = new Subject<any>();\n\n  /**\n   * @description: \n   */\n  private printrun_winning_number: Array<PrintRunWinningNumber> | undefined;\n\n  /**\n   * @description: Envoyer une messages pour indiquer que c'est la fin de partie.\n   */\n  public endpartystream: Subject<any> = new Subject<any>();\n\n  /**\n   * @description:\n   */\n  public caps: CapsuleTime = new CapsuleTime();\n\n  // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [PARAMS]\n  /**\n   * @description: \n   * @param.time -> the time in the game in second\n   * @param.utc_timestamp the utc timestamp of the game server.\n   * @param.recept_time the time when the client receive the message.\n   */\n  public init_party: TimeParty = {\n    time: 0, \n    utc_timestamp: 0,\n  };\n\n  /**\n   * @description: \n   */\n  public party = {\n    time: 0,\n  };\n\n  /**\n   * @description: \n   */\n  public timestrategy: Array<TimeStrategy> = [];\n\n  // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [LOGIC]\n\n  constructor(\n    private balanceService: BalanceService,\n    private userService: UserService, \n  ) {\n    // TODO: Il faut creer un process de reset puissant pour chaque party\n    setTimeout(() => {\n      this.update_time();\n    }, 1000);\n  }\n\n  /** \n   * @description: update the time in the game. \n   */\n  public update_time() {\n    // alert ('aoeoauoea')\n    if (this.init_party.recept_time === undefined) {\n      setTimeout(() => {\n        this.update_time();\n      }, 200);\n      return;\n    }\n\n    // -> La difference entre le temps actuel et le temps de reception de l'initialisation.\n    let diff_begin_now: number = (new Date().getTime() / 1000) - this.init_party.recept_time.getTime() / 1000;\n    \n    // -> La taille d'une partie en seconde.\n    let party_duration: number = this.get_party_duration();\n    \n    // -> La difference entre le temps actuel et le temps de reception de l'initialisation.\n    let party = diff_begin_now % party_duration;\n\n    this.party.time = this.init_party.time + party;\n    this.party.time = this.party.time % party_duration;\n\n    this.caps = this.getTimeLaps(this.party.time);\n    this.stream.next({\n      event: 'party_time',\n      data: {\n        time: this.party.time,\n        caps: this.caps,\n      },\n    });\n\n    // TODO: Il y aurait un bug a ce niveaux.\n    try {\n      setTimeout(() => {\n        this.update_time();\n      }, 200);\n    } catch (error) { }\n  }\n\n  /**\n   * @description: Get the duration maximum for the party, based in the timestrategy\n   */\n  public get_party_duration() { \n    let max_duration_encountred = 0;\n    for (let i = 0; i < this.timestrategy.length; i++) {\n      const element = this.timestrategy[i];\n      if (element.time_end > max_duration_encountred) {\n        max_duration_encountred = element.time_end;\n      }\n    }\n    return max_duration_encountred;\n  }\n\n  /**\n   * @description: \n   * @param data \n   */\n  public get_timelaps(timelas: TimeStrategyTimeLaps) {\n    return timelas.time_end - timelas.time_start;\n  }\n\n  /**\n   * @description: \n   */\n  public getTimeLaps(time: number) {\n    let timelaps: TimeStrategyTimeLaps | undefined;\n    let timelaps_list: Array<string> = [];\n    console.log(time)\n    for (let i = 0; i < this.timestrategy.length; i++) {\n      const element = this.timestrategy[i];\n      if (time >= element.time_start && time <= element.time_end) {\n        timelaps_list.push(element.key);\n      }\n    }\n\n    let capsule = new CapsuleTime();\n    capsule.list_timelaps = timelaps_list;\n    return capsule;\n  }\n\n  // @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ [RECEPTOR]\n  /**\n   * @description: \n   */\n  public recept__lottery_ticket_values(data: any): void {\n    this.stream.next({\n      event: 'lottery_ticket_values',\n      data: data,\n    });\n  }\n\n  /**\n   * @description: \n   */\n  public recept__timestrategy(data: Array<TimeStrategy>): void {\n    this.timestrategy = data;\n  }\n\n  /**\n   * @description: \n   */\n  public recept__initparty(data: any): void {\n    Object.assign(this.init_party, data);\n    this.init_party.recept_time = new Date();\n    this.get_party_duration();\n  }\n\n  /**\n   * @description: \n   */\n  public recept__account_balance(data: any) {\n    this.balanceService.setBalance(data);\n    this.recept__ticket_list(data);\n    // this.stream.next({\n    //   event: 'account_balance',\n    //   data: data,\n    // });\n  }\n\n  /**\n   * @description:\n   */\n  public recept__party_value(data: any) { }\n\n  /**\n   * @description:\n   */\n  public recept__playing(data: any) { }\n\n  /**\n   * @description:\n   */\n  public recept__ticket_list(data: any) {\n    if (typeof data === 'number') {\n      return;\n    }\n\n    this.stream.next({\n      event: 'ticket_list',\n      data: data,\n    });\n  }\n\n  /**\n   * @description: \n   */\n  public recept__error(data: any) { }\n\n  /**\n   * @description: \n   */\n  public recept__winner_list(data: any) {\n\n  }\n\n  /**\n   * @description: \n   */\n  public recept__jackpot(data: any) {\n    this.stream.next({\n      event: 'jackpot',\n      data: data,\n    });\n  }\n\n  /**\n   * @description: \n   */\n  public recept__winning_number(data: any) {\n    this.printrun_winning_number = data;\n    this.printrun_run();\n  }\n\n  /**\n   * @description:\n   */\n  public recept__new_party(data: any): void {\n    window.location.reload();\n  }\n\n  /**\n   * @description:\n   */\n  public send_selected_ticket(ticket: any): void {\n    this.ws_connection?.wsService.send(\n      this.ws_connection,\n      {\n        play: ticket.value,\n    });\n  }\n\n  /**\n   * @description:\n   */\n  public printrun_run(): void {\n    setTimeout(() => {\n      if (this.printrun_winning_number === undefined) {\n        return; \n      };\n\n      if (!this.caps.random_draw()) {\n        this.printrun_run(); \n        return;\n      }\n\n      for (let bobine of this.printrun_winning_number) {\n        if (bobine.sended) { continue; }\n\n        if (bobine.whentotime <= this.party.time) {\n          bobine.sended = true;\n          this.stream_winning_number.next(bobine);\n        }\n      }\n      this.printrun_run();\n    }, 500);\n  }\n\n  /**\n   * @description:\n   */\n  public endpartynext(event: 'gameover' | 'win' | 'reset'): void {\n    if (!this.userService.is_authenticated()) {\n      if (this.caps.random_draw()) {\n        this.endpartynext('reset');\n      }\n      return;\n    }\n    this.endpartystream.next(event);\n  }\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}